#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <ctype.h>
#include <getopt.h>
#include <stdbool.h>

// Need to convert YUV422 to RGB24
// The YUV422 data format shares U and V values between two pixels. As a result, these values are transmitted to the PC image buffer only once for every two pixels, resulting in an average transmission rate of 16 bits per pixel.
// https://www.flir.com/support-center/iis/machine-vision/knowledge-base/understanding-yuv-data-formats/#:~:text=The%20YUV422%20data%20format%20shares,V2%20Y3%20U4%20Y4%20V4%E2%80%A6
// U0 Y0 V0 Y1 U2 Y2 V2 Y3 U4 Y4 V4â€¦
//#define YUV422

// But my USB camera outputs 'YUYV' (YUYV 4:2:2) which is indeed Y U Y2 V
// YUY2: "Known as YUY2, YUYV, V422 or YUNV"
// https://stackoverflow.com/questions/36228232/yuy2-vs-yuv-422
// #define YUYV

typedef enum YUVFORMAT {
	YUV422,
	YUYV
} yuvformat_t;

yuvformat_t FORMAT = YUYV;

/*
  Compile thusly:
  gcc -Wall -o yuv2ppm yuv2ppm.c
*/
/* example.ppm
P3
# feep.ppm
4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
*/

// PPM can be binary or ASCII
bool BINOUTPUT = false;
bool VERBOSE = false;

uint16_t IMAGE_W = 1920;
uint16_t IMAGE_H = 1080;

uint8_t ALGO = 5;

int make_outfile(char *outfile, char *infile)
{
   int i;

   for(i=0; infile[i]; i++) outfile[i] = infile[i];
   outfile[i++] = '.';
   outfile[i++] = 'p';
   outfile[i++] = 'p';
   outfile[i++] = 'm';
   outfile[i++] = 0;

   return 0;
}

void yuv2rgb(double y, double u, double v, uint8_t *r, uint8_t *g, uint8_t *b)
{
   double R, G, B;

   if (ALGO == 1) {
     // This is actually an YCbCr conversion. Not suitable for YUV.
     R = 1.164 * (y - 16) +                     2.018 * (v - 128);
     G = 1.164 * (y - 16) - 0.813 * (u - 128) - 0.391 * (v - 128);
     B = 1.164 * (y - 16) + 1.596 * (u - 128);
   } else if (ALGO == 2) {
     // This is actually an YCbCr conversion. Not suitable for YUV.
     R = 1.164 * (y - 16)	                   + 1.596 * (v - 128);
     G = 1.164 * (y - 16) - 0.391 * (u - 128) - 0.813 * (v - 128);
     B = 1.164 * (y - 16) + 2.018 * (u - 128);
   } else if (ALGO == 3) {
     // This seems to have the least amount of math and display is ok
     R = y	                     + 1.370705 * (v-128);
     G = y	- 0.337633 * (u-128) - 0.698001 * (v-128);
     B = y	+ 1.732446 * (u-128);
   } else if (ALGO == 4) {
     // This looks short but the colors are wrong
     R = y + 1.403 * v;
     G = y - 0.344 * u - 0.714 * v;
     B = y + 1.770 * u;
   } else if (ALGO == 5) {
     // HDTV values taken from wikipedia (BT.709)
     R = y	                    + 1.28033 * (v-128);
     G = y	- 0.21482 * (u-128) - 0.38059 * (v-128);
     B = y	+ 2.12798 * (u-128);
   } else if (ALGO == 6) {
     // SDTV values taken from wikipedia (BT.470)
     R = y	                    + 1.13982 * (v-128);
     G = y	- 0.39465 * (u-128) - 0.58060 * (v-128);
     B = y	+ 2.03211 * (u-128);
   } else {
     printf("Invalid algorithm.\n");
     exit(-1);
   }

   // Even with proper conversion, some values still need clipping.
   if (R > 255) R = 255;
   if (G > 255) G = 255;
   if (B > 255) B = 255;
   if (R < 0) R = 0;
   if (G < 0) G = 0;
   if (B < 0) B = 0;

   *r = (uint8_t)R;
   *g = (uint8_t)G;
   *b = (uint8_t)B;

   if (VERBOSE)
      printf("yuv2rgb(%2f, %2f, %2f) -> %2x, %2x, %2x\n", y, u, v, *r, *g, *b);

   return;
}

int yuv2ppm(char *infile, char *outfile)
{
   FILE *in, *out;
   uint8_t y, u, v, y2;
   uint8_t r, g, b;
   const char ppmheader[] = "# Generated by yuv2ppm\n";

   in = fopen(infile, "rb");
   out = fopen(outfile, "wb");

   if (!in  ||  !out)
      return 0;

   if (BINOUTPUT)
      fprintf(out, "P6\n");
   else
      fprintf(out, "P3\n");

   fprintf(out, ppmheader);
   fprintf(out, "%i %i\n255\n", IMAGE_W, IMAGE_H);

   for(int i=0; i<IMAGE_W*IMAGE_H/2; i++)
   {
      // https://www.flir.com/support-center/iis/machine-vision/knowledge-base/understanding-yuv-data-formats/#:~:text=The%20YUV422%20data%20format%20shares,V2%20Y3%20U4%20Y4%20V4%E2%80%A6
      // U0 Y0 V0 Y1 U2 Y2 V2 Y3
      if (FORMAT == YUV422) {
        fread(&u, 1, 1, in);
        fread(&y, 1, 1, in);
        fread(&v, 1, 1, in);
        fread(&y2, 1, 1, in);
      // called YUY2 in mplayer, mplayer -demuxer rawvideo -rawvideo w=320:h=240:format=yuy2 out.yuyv
      } else if (FORMAT == YUYV) {
        fread(&y, 1, 1, in);
        fread(&u, 1, 1, in);
        fread(&y2, 1, 1, in);
        fread(&v, 1, 1, in);
      } else {
      	printf("Unknown YUV format\n");
          exit(-1);
      }

      if (VERBOSE)
         printf("u:%2x y:%2x v:%2x y2:%2x\n", u, y, v, y2);

      yuv2rgb(y, u, v, &r, &g, &b);

      if (BINOUTPUT) {
        fwrite(&r, 1, 1, out);
        fwrite(&g, 1, 1, out);
        fwrite(&b, 1, 1, out);
        yuv2rgb(y2, u, v, &r, &g, &b);
        fwrite(&r, 1, 1, out);
        fwrite(&g, 1, 1, out);
        fwrite(&b, 1, 1, out);
      } else {
        fprintf(out, "%u %u %u\n", r, g, b);
        fprintf(out, "%u %u %u\n", r, g, b);
      }
   }

   fclose(in);
   fclose(out);

   return 1;
}

void print_help()
{
   printf("Converts yuv images to ppm.\n");
   printf("Possible options:\n");
   printf("  -b		Output in binary form (default: false)\n");
   printf("  -a <1-4>	The algorighm to use (default: %i)\n", ALGO);
   printf("  -W <width>	Image width in pixel (default: %i)\n", IMAGE_W);
   printf("  -W <width>	Image width in pixel (default: %i)\n", IMAGE_W);
   printf("  -f <fmt>	Input YUV format to use (default: %i)\n", FORMAT);
   printf("		Possible values:\n");
   printf("		  0: YUV422\n");
   printf("		  1: YUYV\n");
   printf("  -v		Be verbose\n");
   printf("  -h		Print this help\n");
}

int main(int argc, char **argv)
{
  char *infile, outfile[256];
  int i, c, success;

  opterr = 0;

  while ((c = getopt(argc, argv, "va:bH:W:h")) != -1) {
     switch (c) {
     case 'h':
        print_help();
        exit(0);
        break;
     case 'b':
        BINOUTPUT = true;
        break;
     case 'v':
        VERBOSE = true;
        break;
     case 'a':
        ALGO = atoi(optarg);
        break;
     case 'H':
        IMAGE_H = atoi(optarg);
        break;
     case 'W':
        IMAGE_W = atoi(optarg);
        break;
     case '?':
        if (optopt == 'W' || optopt == 'H')
           fprintf(stderr, "Option -%c requires an argument.\n", optopt);
        else if (isprint(optopt))
           fprintf(stderr, "Unknown option `-%c'.\n", optopt);
        else
           fprintf(stderr,
                    "Unknown option character `\\x%x'.\n",
                    optopt);
        return 1;
     default:
        exit(0);
     }
  }


  for(i=optind; i<argc; i++)
  {
     success = 0;
     infile = argv[i];
     make_outfile(outfile, infile);

     printf("%s -> %s\n", infile, outfile);
     fflush(stdout);
     success = yuv2ppm(infile, outfile);

     if(success)
     {
       printf("Done.\n");
     }
     else
     {
       printf("Failed.  Aborting.\n");
       return 1;
     }
  }
  return 0;
}
